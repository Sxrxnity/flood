#######################################################################################
########################## COMP1521 25T2 ASSIGNMENT 1: Flood ##########################
##                                                                                   ##
## !!! IMPORTANT !!!                                                                 ##
## Before starting work on the assignment, make sure you set your tab-width to 8!    ##
## It is also suggested to indent with tabs only.                                    ##
## Instructions to configure your text editor can be found here:                     ##
##   https://cgi.cse.unsw.edu.au/~cs1521/current/resources/mips-editors.html         ##
## !!! IMPORTANT !!!                                                                 ##
##                                                                                   ##
## This program was written by Danny Sun (z5691331)                            	     ##
## on 18/06/2025                                                              	     ##
##                                                                                   ##
## HEY! HEY YOU! Fill this header comment in RIGHT NOW!!! Don't miss out on that     ##
## precious style mark!!      >:O                                                    ##


########################################
## CONSTANTS: REQIURED FOR GAME LOGIC ##
########################################

TRUE = 1
FALSE = 0

UP_KEY = 'w'
LEFT_KEY = 'a'
DOWN_KEY = 's'
RIGHT_KEY = 'd'

FILL_KEY = 'e'

CHEAT_KEY = 'c'
HELP_KEY = 'h'
EXIT_KEY = 'q'

COLOUR_ONE = '='
COLOUR_TWO = 'x'
COLOUR_THREE = '#'
COLOUR_FOUR = '.'
COLOUR_FIVE = '*'
COLOUR_SIX = '`'
COLOUR_SEVEN = '@'
COLOUR_EIGHT = '&'

NUM_COLOURS = 8

MIN_BOARD_WIDTH = 3
MAX_BOARD_WIDTH = 12
MIN_BOARD_HEIGHT = 3
MAX_BOARD_HEIGHT = 12

BOARD_VERTICAL_SEPERATOR = '|'
BOARD_CROSS_SEPERATOR = '+'
BOARD_HORIZONTAL_SEPERATOR = '-'
BOARD_CELL_SEPERATOR = '|'
BOARD_SPACE_SEPERATOR = ' '
BOARD_CELL_SIZE = 3

SELECTED_ARROW_VERTICAL_LENGTH = 2

GAME_STATE_PLAYING = 0
GAME_STATE_LOST = 1
GAME_STATE_WON = 2

NUM_VISIT_DELTAS = 4
VISIT_DELTA_ROW = 0
VISIT_DELTA_COL = 1

MAX_SOLUTION_STEPS = 64

NOT_VISITED = 0
VISITED = 1
ADJACENT = 2

EXTRA_STEPS = 2

#################################################
## CONSTANTS: PLEASE USE THESE FOR YOUR SANITY ##
#################################################

SIZEOF_INT = 4
SIZEOF_PTR = 4
SIZEOF_CHAR = 1

##########################################################
## struct fill_in_progress {                            ##
##     int cells_filled;                                ##
##     char visited[MAX_BOARD_WIDTH][MAX_BOARD_HEIGHT]; ##
##     char fill_with;                                  ##
##     char fill_onto;                                  ##
## };                                                   ##
##########################################################

CELLS_FILLED_OFFSET = 0
VISITED_OFFSET = CELLS_FILLED_OFFSET + SIZEOF_INT
FILL_WITH_OFFSET = VISITED_OFFSET + MAX_BOARD_WIDTH * MAX_BOARD_HEIGHT * SIZEOF_CHAR
FILL_ONTO_OFFSET = FILL_WITH_OFFSET + SIZEOF_CHAR

SIZEOF_FILL_IN_PROGRESS = FILL_ONTO_OFFSET + SIZEOF_CHAR

############################
## struct step_rating {   ##
##     int surface_area;  ##
##     int is_eliminated; ##
## };                     ##
############################

SURFACE_AREA_OFFSET = 0
IS_ELIMINATED_OFFSET = SURFACE_AREA_OFFSET + SIZEOF_INT

STEP_RATING_ALIGNMENT = 0

SIZEOF_STEP_RATING = IS_ELIMINATED_OFFSET + SIZEOF_INT + STEP_RATING_ALIGNMENT

###################################################################
## struct solver {                                               ##
##     struct step_rating step_rating_for_colour[NUM_COLOURS];   ##
##     int solution_length;                                      ##
##     char simulated_board[MAX_BOARD_WIDTH][MAX_BOARD_HEIGHT];  ##
##     char future_board[MAX_BOARD_WIDTH][MAX_BOARD_HEIGHT];     ##
##     char adjacent_to_cell[MAX_BOARD_WIDTH][MAX_BOARD_HEIGHT]; ##
##     char optimal_solution[MAX_SOLUTION_STEPS];                ##
## };                                                            ##
###################################################################

STEP_RATING_FOR_COLOUR_OFFSET = 0
SOLUTION_LENGTH_OFFSET = STEP_RATING_FOR_COLOUR_OFFSET + SIZEOF_STEP_RATING * NUM_COLOURS
SIMULATED_BOARD_OFFSET = SOLUTION_LENGTH_OFFSET + SIZEOF_INT
FUTURE_BOARD_OFFSET = SIMULATED_BOARD_OFFSET + MAX_BOARD_WIDTH * MAX_BOARD_HEIGHT * SIZEOF_CHAR
ADJACENT_TO_CELL_OFFSET = FUTURE_BOARD_OFFSET + MAX_BOARD_WIDTH * MAX_BOARD_HEIGHT * SIZEOF_CHAR
OPTIMAL_SOLUTION_OFFSET = ADJACENT_TO_CELL_OFFSET + MAX_BOARD_WIDTH * MAX_BOARD_HEIGHT * SIZEOF_CHAR

SIZEOF_SOLVER = OPTIMAL_SOLUTION_OFFSET + MAX_SOLUTION_STEPS * SIZEOF_CHAR

###################
## END CONSTANTS ##
###################

########################################
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
########################################

######################
## GLOBAL VARIABLES ##
######################

	.data

###############################################
## char selected_arrow_horizontal[] = "<--"; ##
###############################################

selected_arrow_horizontal:
	.asciiz "<--"

##################################################
## char selected_arrow_vertical[] = {'^', '|'}; ##
##################################################

selected_arrow_vertical:
	.ascii "^|"

################################
## char cmd_waiting[] = "> "; ##
################################

cmd_waiting:
	.asciiz "> "

############################################################
## char colour_selector[NUM_COLOURS] = {                  ##
##    COLOUR_ONE, COLOUR_TWO, COLOUR_THREE, COLOUR_FOUR,  ##
##    COLOUR_FIVE, COLOUR_SIX, COLOUR_SEVEN, COLOUR_EIGHT ##
## };                                                     ##
############################################################

colour_selector:
	.byte COLOUR_ONE, COLOUR_TWO, COLOUR_THREE, COLOUR_FOUR
	.byte COLOUR_FIVE, COLOUR_SIX, COLOUR_SEVEN, COLOUR_EIGHT

#########################################################
## char game_board[MAX_BOARD_WIDTH][MAX_BOARD_HEIGHT]; ##
#########################################################

game_board:
	.align 2
	.space MAX_BOARD_WIDTH * MAX_BOARD_HEIGHT

##################################################################
## int visit_deltas[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; ##
##################################################################

visit_deltas:
	.word -1, 0
	.word 1, 0
	.word 0, -1
	.word 0, 1

#######################
## int selected_row; ##
#######################

selected_row:
	.align 2
	.space 4

##########################
## int selected_column; ##
##########################

selected_column:
	.align 2
	.space 4

######################
## int board_width; ##
######################

board_width:
	.align 2
	.space 4

#######################
## int board_height; ##
#######################

board_height:
	.align 2
	.space 4

################################################
## char optimal_solution[MAX_SOLUTION_STEPS]; ##
################################################

optimal_solution:
	.align 2
	.space MAX_SOLUTION_STEPS * SIZEOF_CHAR

########################
## int optimal_steps; ##
########################

optimal_steps:
	.align 2
	.space 4

######################
## int extra_steps; ##
######################

extra_steps:
	.align 2
	.space 4

################
## int steps; ##
################

steps:
	.align 2
	.space 4


#####################
## int game_state; ##
#####################

game_state:
	.align 2
	.space 4

###############################
## unsigned int random_seed; ##
###############################

random_seed:
	.align 2
	.space 4

######################################################
## struct fill_in_progress global_fill_in_progress; ##
######################################################

global_fill_in_progress:
	.align 2
	.space SIZEOF_FILL_IN_PROGRESS

##################################
## struct solver global_solver; ##
##################################

global_solver:
	.align 2
	.space SIZEOF_SOLVER

########################################
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
########################################

##########################
## END GLOBAL VARIABLES ##
##########################

####################
## STATIC STRINGS ##
####################

########################################
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
########################################

	.data

str_print_welcome_1:
	.asciiz "Welcome to flood!\n"

str_print_welcome_2:
	.asciiz "To move your cursor up/down, use "

str_print_welcome_3:
	.asciiz "To move your cursor left/right, use "

str_print_welcome_4:
	.asciiz "To see this message again, use "

str_print_welcome_5:
	.asciiz "To perform flood fill on the grid, use "

str_print_welcome_6:
	.asciiz "To cheat and see the 'optimal' solution, use "

str_print_welcome_7:
	.asciiz "To exit, use "


str_game_loop_win:
	.asciiz "You win!\n"

str_game_loop_lose:
	.asciiz "You lose :(\n"

str_initialise_game_enter_width:
	.asciiz "Enter the grid width: "

str_initialise_game_enter_height:
	.asciiz "Enter the grid height: "

str_initialise_game_invalid_width:
	.asciiz "Invalid width!\n"

str_initialise_game_invalid_height:
	.asciiz "Invalid height!\n"

str_initialise_game_enter_seed:
	.asciiz "Enter a random seed: "

str_do_fill_filled_1:
	.asciiz "Filled "

str_do_fill_filled_2:
	.asciiz " cells!\n"

str_print_board_steps:
	.asciiz " steps\n"

str_process_command_unknown:
	.asciiz "Unknown command: "

########################################
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
## DO NOT MODIFY THE .DATA SECTION!!! ##
########################################

########################
## END STATIC STRINGS ##
########################


############################################################
####                                                    ####
####   Your journey begins here, intrepid adventurer!   ####
####                                                    ####
############################################################

##############
## SUBSET 0 ##
##############

#####################
## int main(void); ##
#####################

################################################################################
# .TEXT <main>
	.text
main:
	# Subset:   0
	#
	# Frame:
	#   - $ra, $fp
	#
	# Uses:
	#   - $v0
	#
	# Clobbers:
	#   - $v0
	#
	# Locals:
	#   - None
	#
	# Structure:
	#   main
	#   -> main__prologue
	#   -> main__body
	#   -> main__epilogue

main__prologue:
	BEGIN
	push 	$ra

main__body:
	jal	print_welcome				# print_welcome();
	jal 	initialise_game				# initialise_game();
	jal	game_loop				# game_loop();

main__epilogue:
	li 	$v0, 0
	pop 	$ra
	END
	jr	$ra					# return 0;



###########################
## void print_welcome(); ##
###########################

################################################################################
# .TEXT <print_welcome>
	.text
print_welcome:
	# Subset:   0
	#
	# Frame: None
	#
	# Uses:
	#   - $a0
	#   - $v0
	#
	# Clobbers:
	#   - $a0
	#   - $v0
	#
	# Locals:
	#   - None
	#
	# Structure:
	#   print_welcome
	#   -> print_welcome__prologue
	#   -> print_welcome__body
	#   -> print_welcome__epilogue

print_welcome__prologue:
	BEGIN

print_welcome__body:
	li 	$v0, 4
	la 	$a0, str_print_welcome_1
	syscall						# printf("Welcome to flood!\n");

	la 	$a0, str_print_welcome_2
	syscall						# printf("To move your cursor up/down, use ");
	li 	$v0, 11
	la 	$a0, UP_KEY
	syscall						# printf("%c", UP_KEY);
	li 	$a0, '/'
	syscall						# printf("/");
	la 	$a0, DOWN_KEY
	syscall						# printf("%c", DOWN_KEY);
	li 	$a0, '\n'
	syscall						# printf("\n");

	li 	$v0, 4
	la 	$a0, str_print_welcome_3
	syscall						# printf("To move your cursor left/right, use ");
	li 	$v0, 11
	la 	$a0, LEFT_KEY
	syscall						# printf("%c", LEFT_KEY);
	li 	$a0, '/'
	syscall						# printf("/");
	la 	$a0, RIGHT_KEY
	syscall						# printf("%c", RIGHT_KEY);
	li 	$a0, '\n'
	syscall						# printf("\n");

	li 	$v0, 4
	la 	$a0, str_print_welcome_4
	syscall						# printf("To see this message again, use ");
	li 	$v0, 11
	la 	$a0, HELP_KEY
	syscall						# printf("%c", HELP_KEY);
	li 	$a0, '\n'
	syscall						# printf("\n");

	li 	$v0, 4
	la 	$a0, str_print_welcome_5
	syscall						# printf("To perform flood fill on the grid, use ");
	li 	$v0, 11
	la 	$a0, FILL_KEY
	syscall						# printf("%c", FILL_KEY);
	li 	$a0, '\n'
	syscall						# printf("\n");

	li 	$v0, 4
	la 	$a0, str_print_welcome_6
	syscall                             		# printf("To cheat and see the 'optimal' solution, use ");
	li 	$v0, 11
	li 	$a0, CHEAT_KEY
	syscall                             		# printf("%c", CHEAT_KEY);
	li 	$a0, '\n'
	syscall                             		# printf("\n");

	li 	$v0, 4
	la 	$a0, str_print_welcome_7
	syscall                             		# printf("To exit, use ");
	li 	$v0, 11
	li 	$a0, EXIT_KEY
	syscall                             		# printf("%c", EXIT_KEY);
	li 	$a0, '\n'
	syscall                             		# printf("\n");

print_welcome__epilogue:
	END
	jr	$ra



##############
## SUBSET 1 ##
##############

#########################################################
## int in_bounds(int value, int minimum, int maximum); ##
#########################################################

################################################################################
# .TEXT <in_bounds>
	.text
in_bounds:
	# Subset:   1
	#
	# Frame: None
	#
	# Uses:
	#   - $a0, $a1, $a2
	#   - $v0
	#
	# Clobbers:
	#   - $v0
	#
	# Locals:
	#   - None
	#
	# Structure:
	#   in_bounds
	#   -> in_bounds__prologue
	#   -> in_bounds__body
	#     -> in_bounds_return_false
	#     -> in_bounds_return_true
	#   -> in_bounds__epilogue

in_bounds__prologue:
	BEGIN

in_bounds__body:
	bgt	$a1, $a0, in_bounds_return_false    # if (value < minimum);
	bgt	$a0, $a2, in_bounds_return_false    # if (value > maximum);

in_bounds_return_true:
	li 	$v0, 1                              # return_val = 1;
	j	in_bounds__epilogue

in_bounds_return_false:
	li 	$v0, 0                              # return_val = 0;

in_bounds__epilogue:
	END
	jr	$ra                                 # return return_val;



#######################
## void game_loop(); ##
#######################

################################################################################
# .TEXT <game_loop>
	.text
game_loop:
	# Subset:   1
	#
	# Frame:
	#   - $ra, $fp
	#
	# Uses:
	#   - $a0
	#   - $v0
	#   - $t0
	#
	# Clobbers:
	#   - $a0
	#   - $v0
	#   - $t0
	#
	# Locals:
	#   - $t0: stores game state
	#
	# Structure:
	#   game_loop
	#   -> game_loop__prologue
	#   -> game_loop__body
	#     -> game_state_playing_condition
	#     -> game_state_playing_body
	#     -> game_state_playing_end
	#     -> game_state_won
	#     -> game_state_lost
	#   -> game_loop__epilogue

game_loop__prologue:
	BEGIN
	push 	$ra

game_loop__body:
	la 	$a0, game_board 	 	        		# print_board(game_board);
	jal 	print_board

game_state_playing_condition:
	lw 	$t0, game_state
	bne 	$t0, GAME_STATE_PLAYING, game_state_playing_end   	# while (game_state == GAME_STATE_PLAYING)

game_state_playing_body:
	jal	process_command                 			# process_command();
	j 	game_state_playing_condition

game_state_playing_end:
	beq 	$t0, GAME_STATE_WON, game_state_won		        # if (game_state == GAME_STATE_WON)
	beq 	$t0, GAME_STATE_LOST, game_state_lost		        # if (game_state == GAME_STATE_LOST)
	j 	game_loop__epilogue

game_state_won:
	li 	$v0, 4
	la	$a0, str_game_loop_win
	syscall                                 			# printf("You win!\n");
	j 	game_loop__epilogue

game_state_lost:
	li 	$v0, 4
	la	$a0, str_game_loop_lose
	syscall                                 			# printf("You lose :(\n");
	j 	game_loop__epilogue

game_loop__epilogue:
	pop 	$ra
	END
	jr	$ra                                   			# return;



#############################
## void initialise_game(); ##
#############################

################################################################################
# .TEXT <initialise_game>
	.text
initialise_game:
	# Subset:   1
	#
	# Frame:
	#   - $ra, $fp
	#
	# Uses:
	#   - $a0, $a1, $a2
	#   - $v0
	#   - $t1, $t2, $t3, $t4
	#
	# Clobbers:
	#   - $a0, $a1, $a2
	#   - $v0
	#   - $t1, $t2, $t3, $t4
	#
	# Locals:
	#   - $t1: user_width
	#   - $t2: user_height
	#   - $t3: user input for seed
	#   - $t4: used to set game state variables
	#
	# Structure:
	#   initialise_game
	#   -> initialise_game__prologue
	#   -> initialise_game__body
	#     -> initialise_game__print_invalid_width
	#     -> initialise_game__print_invalid_height
	#   -> initialise_game__end
	#   -> initialise_game__epilogue

initialise_game__prologue:
	BEGIN
	push 	$ra

initialise_game__body:
	li 	$v0, 4
	la 	$a0, str_initialise_game_enter_width
	syscall                                 		# printf("Enter the grid width: ");

	li 	$v0, 5
	syscall							# scanf(" %d", &user_width);
	move 	$t1, $v0
	sw 	$t1, board_width                   		# board_width = user_width;

	move 	$a0, $t1
	la 	$a1, MIN_BOARD_WIDTH
	la 	$a2, MAX_BOARD_WIDTH
	jal 	in_bounds                         		# if (!in_bounds())

	beqz 	$v0, initialise_game__print_invalid_width       # printf("Invalid width!\n"); continue;

	li 	$v0, 4
	la 	$a0, str_initialise_game_enter_height
	syscall                                 		# printf("Enter the grid height: ");

	li 	$v0, 5
	syscall							# scanf(" %d", &user_height);
	move 	$t2, $v0
	sw 	$t2, board_height                  		# board_height = user_height;

	move 	$a0, $t2
	la 	$a1, MIN_BOARD_HEIGHT
	la 	$a2, MAX_BOARD_HEIGHT
	jal 	in_bounds                         		# if (!in_bounds(...))

	beqz 	$v0, initialise_game__print_invalid_height      # printf("Invalid height!\n"); continue;

	j 	initialise_game__end               		# break;

initialise_game__print_invalid_width:
	li 	$v0, 4
	la 	$a0, str_initialise_game_invalid_width
	syscall                                 		# printf("Invalid width!\n");
	j	initialise_game__body              		# continue;


initialise_game__print_invalid_height:
	li 	$v0, 4
	la 	$a0, str_initialise_game_invalid_height
	syscall                                 		# printf("Invalid height!\n");
	j	initialise_game__body              		# continue;

initialise_game__end:
	li 	$v0, 4
	la 	$a0, str_initialise_game_enter_seed
	syscall                                 		# printf("Enter a random seed: ");

	li 	$v0, 5
	syscall							# scanf(" %d", &user_random_seed);
	sw 	$v0, random_seed                   		# random_seed = user_random_seed;

	sw 	$zero, selected_row                  		# selected_row = 0;
	sw 	$zero, selected_column               		# selected_column = 0;
	sw 	$zero, steps                         		# steps = 0;

	li 	$t4, EXTRA_STEPS
	sw 	$t4, extra_steps                   		# extra_steps = EXTRA_STEPS;

	li 	$t4, GAME_STATE_PLAYING
	sw 	$t4, game_state                    		# game_state = GAME_STATE_PLAYING;

	jal 	initialise_board                  		# initialise_board();
	jal 	find_optimal_solution             		# find_optimal_solution();

initialise_game__epilogue:
	pop 	$ra
	END
	jr	$ra                                 		# return;



#######################################################################
## int game_finished(char board[MAX_BOARD_WIDTH][MAX_BOARD_HEIGHT]); ##
#######################################################################

################################################################################
# .TEXT <game_finished>
	.text
game_finished:
	# Subset:   1
	#
	# Frame: None
	#
	# Uses:
	#   - $a0
	#   - $v0
	#   - $t0, $t1, $t2, $t3, $t4, $t5, $t6, $t7
	#
	# Clobbers:
	#   - $a0
	#   - $v0
	#   - $t0, $t1, $t2, $t3, $t4, $t5, $t6, $t7
	#
	# Locals:
	#   - $t0: expected_colour (board[0][0])
	#   - $t1: row index
	#   - $t2: col index
	#   - $t3: board_height
	#   - $t4: board_width
	#   - $t5: offset = row * MAX_BOARD_WIDTH + col
	#   - $t6: current_colour (board[row][col])
	#   - $t7: MAX_BOARD_WIDTH
	#
	# Structure:
	#   game_finished
	#   -> game_finished__prologue
	#   -> game_finished__init
	#   -> game_finished__row_cond
	#     -> game_finished__col_cond
	#       -> game_finished__body
	#     -> game_finished__col_end
	#   -> game_finished__return_false
	#   -> game_finished__epilogue

game_finished__prologue:
	BEGIN

game_finished__init:
    	lb  	$t0, 0($a0)					# char expected_colour = board[0][0];
	li 	$t1, 0						# int row = 0;
	li 	$t2, 0						# int col = 0;
	li 	$v0, TRUE					# return_val = TRUE;
	li 	$t7, MAX_BOARD_WIDTH

	lw 	$t3, board_height				# load board_height
	lw 	$t4, board_width				# load board_width

game_finished__row_cond:
	bge 	$t1, $t3, game_finished__epilogue		# for (int row = 0; row < board_height; row++)

game_finished__col_cond:
	bge 	$t2, $t4, game_finished__col_end		# for (int col = 0; col < board_width; col++)

game_finished__body:
	mul 	$t5, $t1, $t7					# offset = row * MAX_BOARD_WIDTH;
	add 	$t5, $t5, $t2					# offset += col;
	add 	$t5, $a0, $t5
	lb  	$t6, 0($t5)              			# char current_colour = board[row][col]

	bne 	$t0, $t6, game_finished__return_false		# if (board[row][col] != expected_colour);
	addi 	$t2, $t2, 1					# col++;
	j 	game_finished__col_cond

game_finished__col_end:
	li 	$t2, 0						# col = 0;
	addi 	$t1, $t1, 1					# row++;
	j 	game_finished__row_cond

game_finished__return_false:
	li 	$v0, FALSE					# return_val = FALSE;

game_finished__epilogue:
	END
	jr	$ra						# return return_val;



#####################
## void do_fill(); ##
#####################

################################################################################
# .TEXT <do_fill>
	.text
do_fill:
	# Subset:   1
	#
	# Frame:
	#   - $ra, $fp
	#
	# Uses:
	#   - $a0, $a1, $a2, $a3
	#   - $v0
	#   - $t0, $t1, $t2, $t3, $t4
	#
	# Clobbers:
	#   - $a0, $a1, $a2, $a3
	#   - $v0
	#   - $t0, $t1, $t2, $t3, $t4
	#
	# Locals:
	#   - $t0: selected_row, optimal_steps, or step counter
	#   - $t1: selected_column or extra_steps
	#   - $t2: MAX_BOARD_WIDTH or steps
	#   - $t3: offset = row * width + col
	#   - $t4: base address of game_board
	#
	# Structure:
	#   do_fill
	#   -> do_fill__prologue
	#   -> do_fill__body
	#   -> do_fill__game_state_won
	#   -> do_fill__game_state_lost_check
	#     -> do_fill__game_state_lost
	#   -> do_fill__epilogue

do_fill__prologue:
	BEGIN
	push 	$ra

do_fill__body:
	la 	$a0, global_fill_in_progress            # &global_fill_in_progress
	lw   	$t0, selected_row
	lw   	$t1, selected_column
	li   	$t2, MAX_BOARD_WIDTH

	mul  	$t3, $t0, $t2
	add  	$t3, $t3, $t1
	la   	$t4, game_board
	add  	$t3, $t3, $t4

	lb   	$a1, 0($t3)                             # game_board[selected_row][selected_column]
	lb 	$a2, game_board                         # game_board[0][0]
	jal 	initialise_fill_in_progress             # initialise_fill_in_progress(...);

	la   	$a0, global_fill_in_progress
	la 	$a1, game_board
	li 	$a2, 0
	li 	$a3, 0
	jal 	fill                                    # fill(&global_fill_in_progress, game_board, 0, 0);

	li 	$v0, 4
	li 	$a0, str_do_fill_filled_1
	syscall                                         # printf("Filled ");

	li 	$v0, 1
	lw 	$a0, global_fill_in_progress
	syscall                                         # printf("%d", global_fill_in_progress.cells_filled);

	li 	$v0, 4
	li 	$a0, str_do_fill_filled_2
	syscall                                         # printf(" cells!\n");

	lw 	$t0, steps
	addi 	$t0, $t0, 1
	sw 	$t0, steps                              # steps++;

	la 	$a0, game_board
	jal 	game_finished
	beq 	$v0, TRUE, do_fill__game_state_won	# if (game_finished(game_board))

	j 	do_fill__game_state_lost_check

do_fill__game_state_won:
	li 	$t0, GAME_STATE_WON
	sw 	$t0, game_state                         # game_state = GAME_STATE_WON;

do_fill__game_state_lost_check:
	lw 	$t0, optimal_steps
	lw 	$t1, extra_steps
	add 	$t1, $t0, $t1
	lw 	$t2, steps

	bgt 	$t2, $t1, do_fill__game_state_lost      # if (steps > optimal_steps + extra_steps)
	j 	do_fill__epilogue

do_fill__game_state_lost:
	li 	$t0, GAME_STATE_LOST
	sw 	$t0, game_state                         # game_state = GAME_STATE_LOST;

do_fill__epilogue:
	pop 	$ra
	END
	jr	$ra                                     # return;



##############
## SUBSET 2 ##
##############

########################################################################
## void initialise_fill_in_progress(struct fill_in_progress *init_me, ##
##     char fill_with, char fill_onto);                               ##
########################################################################

################################################################################
# .TEXT <initialise_fill_in_progress>
	.text
initialise_fill_in_progress:
	# Subset:   2
	#
	# Frame:
	#   - $ra, $fp
	#
	# Uses:
	#   - $a0, $a1, $a2
	#   - $t0, $t1, $t2, $t3, $t4
	#
	# Clobbers:
	#   - $t0, $t1, $t2, $t3, $t4
	#
	# Locals:
	#   - $t0: MAX_BOARD_WIDTH
	#   - $t1: row loop counter
	#   - $t2: col loop counter
	#   - $t3: board_width / board_height
	#   - $t4: address of visited[row][col]
	#
	# Structure:
	#   initialise_fill_in_progress
	#   -> initialise_fill_in_progress__prologue
	#   -> initialise_fill_in_progress__body
	#     -> initialise_fill_in_progress__row_cond
	#       -> initialise_fill_in_progress__col_cond
	#         -> initialise_fill_in_progress__loop_body
	#       -> initialise_fill_in_progress__col_end
	#   -> initialise_fill_in_progress__epilogue

initialise_fill_in_progress__prologue:
	BEGIN

initialise_fill_in_progress__body:
	sb 	$a1, FILL_WITH_OFFSET($a0)				# init_me->fill_with = fill_with;
	sb 	$a2, FILL_ONTO_OFFSET($a0)				# init_me->fill_onto = fill_onto;
	sw 	$zero, CELLS_FILLED_OFFSET($a0)				# init_me->cells_filled = 0;

	li	$t0, MAX_BOARD_WIDTH
	li 	$t1, 0							# int row = 0;
	li 	$t2, 0							# int col = 0;

initialise_fill_in_progress__row_cond:
	lw 	$t3, board_height
	bge 	$t1, $t3, initialise_fill_in_progress__epilogue		# for (int row = 0 ...)

initialise_fill_in_progress__col_cond:
	lw 	$t3, board_width
	bge 	$t2, $t3, initialise_fill_in_progress__col_end 		# for (int col = 0 ...)

initialise_fill_in_progress__loop_body:
	mul 	$t4, $t1, $t0
	add 	$t4, $t4, $t2
	addi 	$t4, $t4, VISITED_OFFSET

	add 	$t4, $t4, $a0
	sb  	$zero, 0($t4) 						# init_me->visited[row][col] = NOT_VISITED;

	addi 	$t2, $t2, 1						# col++;
	j 	initialise_fill_in_progress__col_cond

initialise_fill_in_progress__col_end:
	li 	$t2, 0
	addi 	$t1, $t1, 1						# row++;
	j 	initialise_fill_in_progress__row_cond

initialise_fill_in_progress__epilogue:
	END
	jr	$ra							# return;



##############################
## void initialise_board(); ##
##############################

################################################################################
# .TEXT <initialise_board>
	.text
initialise_board:
	# Subset:   2
	#
	# Frame:
	#   - $ra, $fp, $s0, $s1
	#
	# Uses:
	#   - $a0, $a1
	#   - $v0
	#   - $s0, $s1
	#   - $t0, $t1, $t2, $t3, $t4
	#
	# Clobbers:
	#   - $a0, $a1
	#   - $v0
	#   - $t0, $t1, $t2, $t3, $t4
	#
	# Locals:
	#   - $s0: row loop counter
	#   - $s1: col loop counter
	#   - $t0: colour_selector_index
	#   - $t1: address of colour_selector[colour_selector_index]
	#   - $t2: colour loaded from selector
	#   - $t3: base address of game_board
	#   - $t4: offset into game_board
	#
	# Structure:
	#   initialise_board
	#   -> initialise_board__prologue
	#   -> initialise_board__body
	#     -> initialise_board__row_loop
	#       -> initialise_board__col_loop
	#     -> initialise_board__end_col_loop
	#   -> initialise_board__epilogue

initialise_board__prologue:
	BEGIN
	push 	$ra
	push 	$s0
	push 	$s1

initialise_board__body:
	li 	$s0, 0                                 			# int row = 0;

initialise_board__row_loop:
	bge 	$s0, MAX_BOARD_HEIGHT, initialise_board__epilogue  	# for (int row = 0 ...)
	li 	$s1, 0                                 			# int col = 0;

initialise_board__col_loop:
	bge 	$s1, MAX_BOARD_WIDTH, initialise_board__end_col_loop  	# for (int col = 0 ...)

	li 	$a0, 0
	li 	$a1, NUM_COLOURS - 1
	jal 	random_in_range                       			# int colour_selector_index = ...

	la 	$t1, colour_selector
	add 	$t1, $t1, $v0
	lb 	$t2, 0($t1)

	la 	$t3, game_board
	mul 	$t4, $s0, MAX_BOARD_WIDTH
	add 	$t4, $t4, $s1
	add 	$t3, $t3, $t4
	sb 	$t2, 0($t3)                            			# game_board[row][col] = ...

	addi 	$s1, $s1, 1                          			# col++;
	j 	initialise_board__col_loop

initialise_board__end_col_loop:
	addi 	$s0, $s0, 1                          			# row++;
	j 	initialise_board__row_loop

initialise_board__epilogue:
	pop 	$s1
	pop 	$s0
	pop 	$ra
	END
	jr 	$ra                                    			# return;



###################################
## void find_optimal_solution(); ##
###################################

################################################################################
# .TEXT <find_optimal_solution>
	.text
find_optimal_solution:
	# Subset:   2
	#
	# Frame:
	#   - $ra, $fp, $s0
	#
	# Uses:
	#   - $a0, $a1, $a2
	#   - $v0
	#   - $s0
	#   - $t0, $t1, $t2, $t3
	#
	# Clobbers:
	#   - $a0, $a1, $a2
	#   - $v0
	#   - $t0, $t1, $t2, $t3
	#
	# Locals:
	#   - $s0: address of simulated_board used in game_finished condition
	#   - $t0: general-purpose temp (global_solver base, array address)
	#   - $t1: offset constants
	#   - $t2: solution_length
	#   - $t3: null terminator ('\0')
	#
	# Structure:
	#   find_optimal_solution
	#   -> find_optimal_solution__prologue
	#   -> find_optimal_solution__loop_init
	#   -> find_optimal_solution__loop_condition
	#   -> find_optimal_solution__loop_body
	#   -> find_optimal_solution__body
	#   -> find_optimal_solution__epilogue

find_optimal_solution__prologue:
	BEGIN
	push 	$ra
	push 	$s0

find_optimal_solution__loop_init:
	la 	$a0, global_solver
	jal 	initialise_solver                       	# initialise_solver(&global_solver);

	la   	$t0, global_solver
	addi 	$s0, $t0, SIMULATED_BOARD_OFFSET

find_optimal_solution__loop_condition:
	move 	$a0, $s0
	jal 	game_finished
	BNE 	$v0, FALSE, find_optimal_solution__body     	# while (!game_finished(...))

find_optimal_solution__loop_body:
	la 	$a0, global_solver
	jal 	solve_next_step                         	# solve_next_step(&global_solver);
	j 	find_optimal_solution__loop_condition

find_optimal_solution__body:
	la   	$t0, global_solver
	addi 	$a0, $t0, OPTIMAL_SOLUTION_OFFSET
	la 	$a1, optimal_solution
	lw 	$a2, SOLUTION_LENGTH_OFFSET($t0)
	jal 	copy_mem                                	# copy_mem(...);

	la 	$t0, optimal_solution
	la 	$t1, global_solver
	lw 	$t2, SOLUTION_LENGTH_OFFSET($t1)
	add 	$t0, $t0, $t2
	li 	$t3, '\0'
	sb 	$t3, 0($t0)                              	# optimal_solution[...] = '\0';

	sw 	$t2, optimal_steps                             	# optimal_steps = global_solver.solution_length;

find_optimal_solution__epilogue:
	pop 	$s0
	pop 	$ra
	END
	jr	$ra                                      	# return;



################################################################
## int invalid_step(struct solver *solver, int colour_index); ##
################################################################

################################################################################
# .TEXT <invalid_step>
	.text
invalid_step:
	# Subset:   2
	#
	# Frame:
	#   - $ra, $fp, $s0, $s1
	#
	# Uses:
	#   - $a0, $a1, $a2
	#   - $v0
	#   - $s0, $s1
	#   - $t0, $t1, $t2, $t3, $t4, $t5, $t6
	#
	# Clobbers:
	#   - $a0, $a1, $a2
	#   - $v0
	#   - $t0, $t1, $t2, $t3, $t4, $t5, $t6
	#
	# Locals:
	#   - $s0: pointer to struct solver
	#   - $s1: colour index
	#
	# Structure:
	#   invalid_step
	#   -> invalid_step__prologue
	#   -> invalid_step__body
	#     -> invalid_step__row_cond
	#       -> invalid_step__col_cond
	#         -> invalid_step__next_col
	#       -> invalid_step__next_row
	#     -> invalid_step__check_found
	#       -> invalid_step__return_false
	#       -> invalid_step__return_true
	#   -> invalid_step__epilogue

invalid_step__prologue:
	BEGIN
	push 	$ra
	push 	$s0
	push 	$s1
	push    $s2

invalid_step__body:
	move 	$s0, $a0
	move 	$s1, $a1

	li      $t0, SIMULATED_BOARD_OFFSET
	add     $t0, $s0, $t0
	lb      $t1, 0($t0)                          		# solver->simulated_board[0][0]

	la      $t2, colour_selector
	add     $t2, $t2, $s1
	lb      $t3, 0($t2)                          		# colour_selector[colour_index]

	beq     $t1, $t3, invalid_step__return_true

	move    $a0, $s0
	jal     initialise_solver_adjacent_cells     		# initialise_solver_adjacent_cells(solver);

	move    $a0, $s0
	li      $a1, 0
	li      $a2, 0
	jal     find_adjacent_cells                 		# find_adjacent_cells(solver, 0, 0);

	li      $s2, FALSE                              	# int found = FALSE;
	li      $t4, 0                               		# int row = 0;

invalid_step__row_cond:
	lw      $t5, board_height
	bge     $t4, $t5, invalid_step__check_found  		# for (int row = 0 ...)

	li      $t6, 0                               		# int col = 0;

invalid_step__col_cond:
	lw      $t5, board_width
	bge     $t6, $t5, invalid_step__next_row     		# for (int col = 0 ...)

	mul     $t7, $t4, MAX_BOARD_WIDTH
	add     $t7, $t7, $t6

	li      $t8, SIMULATED_BOARD_OFFSET
	add     $t8, $s0, $t8
	add     $t8, $t8, $t7
	lb      $t9, 0($t8)                          		# solver->simulated_board[row][col]

	la      $t0, colour_selector
	add     $t0, $t0, $s1
	lb      $t1, 0($t0)                          		# colour_selector[colour_index]

	bne     $t9, $t1, invalid_step__next_col

	li      $t2, ADJACENT_TO_CELL_OFFSET
	add     $t2, $s0, $t2
	add     $t2, $t2, $t7
	lb      $t3, 0($t2)                          		# solver->adjacent_to_cell[row][col]

	bne     $t3, ADJACENT, invalid_step__next_col

	li      $s2, TRUE                               	# found = TRUE;

invalid_step__next_col:
	addi    $t6, $t6, 1					# col++;
	j       invalid_step__col_cond

invalid_step__next_row:
	addi    $t4, $t4, 1					# row++;
	j       invalid_step__row_cond

invalid_step__check_found:
	beq     $s2, TRUE, invalid_step__return_false   	# if (found == TRUE)
	j       invalid_step__return_true

invalid_step__return_true:
	li      $v0, 1                               		# return TRUE
	j       invalid_step__epilogue

invalid_step__return_false:
	li      $v0, 0                               		# return FALSE
	j       invalid_step__epilogue

invalid_step__epilogue:
	pop     $s2
	pop     $s1
	pop     $s0
	pop	$ra
	END
	jr	$ra



####################################
## void print_optimal_solution(); ##
####################################

################################################################################
# .TEXT <print_optimal_solution>
	.text
print_optimal_solution:
	# Subset:   2
	#
	# Frame: None
	#
	# Uses:
	#   - $a0
	#   - $v0
	#   - $t0, $t1, $t2, $t3, $t4
	#
	# Clobbers:
	#   - $a0
	#   - $v0
	#   - $t0, $t1, $t2, $t3, $t4
	#
	# Locals:
	#   - $t0: pointer to current character in optimal_solution
	#   - $t1: index counter used to track position
	#   - $t2: value of steps
	#   - $t3: value of optimal_steps
	#   - $t4: currently loaded character from string
	#
	#
	# Structure:
	#   print_optimal_solution
	#   -> print_optimal_solution__prologue
	#   -> print_optimal_solution__body
	#     -> print_optimal_solution__first_loop_init
	#       -> print_optimal_solution__first_loop_condition
	#         -> print_optimal_solution__first_loop_body
	#           -> print_optimal_solution__first_loop_if
	#           -> print_optimal_solution__first_loop_else
	#     -> print_optimal_solution__early_return
	#     -> print_optimal_solution__second_loop_init
	#       -> print_optimal_solution__second_loop_cond
	#         -> print_optimal_solution__second_loop_first_body
	#           -> print_optimal_solution__second_loop_if
	#           -> print_optimal_solution__second_loop_else
	#         -> print_optimal_solution__second_loop_second_body
	#           -> print_optimal_solution__second_loop_newline
	#   -> print_optimal_solution__epilogue

print_optimal_solution__prologue:
	BEGIN

print_optimal_solution__body:

print_optimal_solution__first_loop_init:
    	la  	$t0, optimal_solution        				# char *s = optimal_solution;
    	li  	$v0, 11

print_optimal_solution__first_loop_condition:
    	lb  	$t4, 0($t0)
   	beq 	$t4, 0, print_optimal_solution__second_loop_init 	# while (*s)

print_optimal_solution__first_loop_body:
    	move 	$a0, $t4
    	syscall

    	addi 	$t0, $t0, 1                 				# s++;
    	lb  	$t4, 0($t0)
    	bne 	$t4, 0, print_optimal_solution__first_loop_if     	# if (*s)
    	j   	print_optimal_solution__first_loop_else

print_optimal_solution__first_loop_if:
    	li  	$a0, ','
    	syscall                          				# putchar(',');

    	li  	$a0, ' '
    	syscall                          				# putchar(' ');

    	j   	print_optimal_solution__first_loop_condition

print_optimal_solution__first_loop_else:
    	li  	$a0, '\n'
    	syscall                         				# putchar('\n');

    	j   	print_optimal_solution__first_loop_condition

print_optimal_solution__early_return:
    	li  	$a0, 10
    	syscall                         				# putchar(10);
	j 	print_optimal_solution__epilogue

print_optimal_solution__second_loop_init:
    	la  	$t0, optimal_solution        				# s = optimal_solution;
    	li  	$t1, 0                       				# int i = 0;
    	lw  	$t2, steps
    	lw  	$t3, optimal_steps
    	bgt 	$t2, $t3, print_optimal_solution__early_return    	# if (steps > optimal_steps)

print_optimal_solution__second_loop_cond:
    	lb  	$t4, 0($t0)
    	beq 	$t4, 0, print_optimal_solution__epilogue         	# while (*s)

print_optimal_solution__second_loop_first_body:
    	beq 	$t1, $t2, print_optimal_solution__second_loop_if  	# if (i == steps)
    	j   	print_optimal_solution__second_loop_else

print_optimal_solution__second_loop_if:
    	li  	$a0, '^'
    	syscall                         				# putchar('^');
    	j   	print_optimal_solution__second_loop_second_body

print_optimal_solution__second_loop_else:
    	li  	$a0, ' '
    	syscall                         				# putchar(' ');
    	j   	print_optimal_solution__second_loop_second_body

print_optimal_solution__second_loop_second_body:
    	li  	$a0, ' '
    	syscall                          				# putchar(' ');

    	li  	$a0, ' '
    	syscall                          				# putchar(' ');

    	addi 	$t0, $t0, 1                 				# s++;
    	addi 	$t1, $t1, 1                 				# i++;
    	lb  	$t4, 0($t0)
    	beq 	$t4, 0, print_optimal_solution__second_loop_newline 	# if (!*s)
    	j   	print_optimal_solution__second_loop_cond

print_optimal_solution__second_loop_newline:
    	li  	$a0, '\n'
    	syscall                          				# putchar('\n');
    	j   	print_optimal_solution__second_loop_cond

print_optimal_solution__epilogue:
	END
    	jr  	$ra                          				# return;



##############
## SUBSET 3 ##
##############

################################################################
## void rate_choice(struct solver *solver, int colour_index); ##
################################################################

################################################################################
# .TEXT <rate_choice>
	.text
rate_choice:
	# Subset:   3
	#
	# Frame:
	#   - $ra, $fp, $s0, $s1, $s2
	#
	# Uses:
	#   - $a0, $a1
	#   - $v0
	#   - $s0, $s1, $s2
	#   - $t0, $t1, $t2, $t3, $t4, $t5, $t6
	#
	# Clobbers:
	#   - $a0, $a1
	#   - $v0
	#   - $t0, $t1, $t2, $t3, $t4, $t5, $t6
	#
	# Locals:
	#   - $s0: pointer to struct step_rating
	#   - $s1: seen flag
	#   - $s2: 2D array offset
	#
	# Structure:
	#   rate_choice
	#   -> rate_choice__prologue
	#   -> rate_choice__body
	#     -> rate_choice__row_loop_cond
	#       -> rate_choice__col_loop_cond
	#         -> rate_choice__loop_body
	#           -> rate_choice__loop_first_if
	#             -> rate_choice__loop_seen_true
	#           -> rate_choice__loop_second_if
	#             -> rate_choice__loop_is_eliminated
	#           -> rate_choice__loop_third_if
	#             -> rate_choice__loop_add_surface_area
	#         -> rate_choice__col_loop_end
	#       -> rate_choice__row_loop_end
	#     -> rate_choice__end
	#       -> rate_choice__end_is_eliminated
	#   -> rate_choice__epilogue

rate_choice__prologue:
	BEGIN
	push 	$ra
	push 	$s0
	push 	$s1
	push 	$s2

rate_choice__body:
	add 	$t0, $a0, STEP_RATING_FOR_COLOUR_OFFSET
	mul 	$t1, $a1, 8
	add 	$s0, $t0, $t1

	addi 	$t0, $s0, IS_ELIMINATED_OFFSET
	li 	$t1, TRUE				# solver->...[colour_index].is_eliminated = TRUE;
	sw 	$t1, ($t0)

	addi 	$t0, $s0, SURFACE_AREA_OFFSET
	li 	$t1, 0					# solver->...[colour_index].surface_area = 0;
	sw 	$t1, ($t0)

	li 	$s1, FALSE				# int seen = FALSE;
	li 	$t0, 0					# int row = 0;
	li 	$t1, 0					# int col = 0;

rate_choice__row_loop_cond:
	lw 	$t2, board_height
	bge 	$t0, $t2, rate_choice__end		# for (int row = 0; row < board_height; row++)

rate_choice__col_loop_cond:
	lw 	$t2, board_width
	bge 	$t1, $t2, rate_choice__row_loop_end	# for (int col = 0; col < board_width; col++)

rate_choice__loop_body:
	mul 	$t3, $t0, MAX_BOARD_WIDTH
	add 	$t3, $t3, $t1
	move 	$s2, $t3

	move 	$t3, $a0
	add 	$t3, $t3, SIMULATED_BOARD_OFFSET
	add 	$t3, $t3, $s2
	lb 	$t4, ($t3)

	la 	$t5, colour_selector
	add 	$t5, $t5, $a1
	lb 	$t6, ($t5)

	beq 	$t4, $t6, rate_choice__loop_seen_true	# if (... == ...)
	j 	rate_choice__loop_second_if

rate_choice__loop_seen_true:
	li 	$s1, TRUE				# seen = TRUE;

rate_choice__loop_second_if:
	move 	$t3, $a0
	add 	$t3, $t3, ADJACENT_TO_CELL_OFFSET
	add 	$t3, $t3, $s2
	lb 	$t4, ($t3)

	beq 	$t4, NOT_VISITED, rate_choice__loop_is_eliminated	# if (... == NOT_VISITED)
	j 	rate_choice__loop_third_if

rate_choice__loop_is_eliminated:
	addi 	$t5, $s0, IS_ELIMINATED_OFFSET
	li 	$t6, FALSE				# solver->...[colour_index].is_eliminated = FALSE;
	sw 	$t6, ($t5)

rate_choice__loop_third_if:
	beq 	$t4, ADJACENT, rate_choice__loop_add_surface_area	# else if (... == ADJACENT)
	j 	rate_choice__col_loop_end

rate_choice__loop_add_surface_area:
	addi 	$t5, $s0, SURFACE_AREA_OFFSET
	lw 	$t6, ($t5)
	addi 	$t6, $t6, 1				# solver->...[colour_index].surface_area++;
	sw 	$t6, ($t5)

rate_choice__col_loop_end:
	addi 	$t1, $t1, 1				# col++;
	j 	rate_choice__col_loop_cond

rate_choice__row_loop_end:
	li 	$t1, 0					# col = 0;
	addi 	$t0, $t0, 1				# row++;
	j 	rate_choice__row_loop_cond

rate_choice__end:
	beqz 	$s1, rate_choice__end_is_eliminated	# if (!seen)
	j 	rate_choice__epilogue

rate_choice__end_is_eliminated:
	addi 	$t5, $s0, IS_ELIMINATED_OFFSET
	li 	$t6, FALSE				# solver->...[colour_index].is_eliminated = FALSE;
	sw 	$t6, ($t5)

rate_choice__epilogue:
	pop 	$s2
	pop 	$s1
	pop 	$s0
	pop 	$ra
	END
	jr	$ra					# return;



########################################################################
## void find_adjacent_cells(struct solver *solver, int row, int col); ##
########################################################################

################################################################################
# .TEXT <find_adjacent_cells>
	.text
find_adjacent_cells:
	# Subset:   3
	#
	# Frame:
	#   - $ra, $s0, $s1, $s2, $s3, $s4, $s5, $s6
	#
	# Uses:
	#   - $a0, $a1, $a2
	#   - $v0
	#   - $s0, $s1, $s2, $s3, $s4, $s5, $s6
	#   - $t0, $t1, $t2, $t3
	#
	# Clobbers:
	#   - $a0, $a1, $a2
	#   - $v0
	#   - $t0, $t1, $t2, $t3
	#
	# Locals:
	#   - $s0: pointer to struct solver
	#   - $s1: row index
	#   - $s2: column index
	#   - $s3: offset = row * MAX_BOARD_WIDTH + col
	#   - $s4: loop index i
	#   - $s5: row delta
	#   - $s6: col delta
	#
	# Structure:
	#   find_adjacent_cells
	#   -> find_adjacent_cells__prologue
	#       -> find_adjacent_cells__body
	#           -> find_adjacent_cells__adjacent_exit
	#           -> find_adjacent_cells__loop_init
	#               -> find_adjacent_cells__loop_cond
	#                   -> find_adjacent_cells__loop_body
	#                   -> find_adjacent_cells__loop_end
	#       -> find_adjacent_cells__epilogue

find_adjacent_cells__prologue:
	BEGIN
	push 	$ra
	push 	$s0
	push 	$s1
	push 	$s2
	push 	$s3
	push 	$s4
	push 	$s5
	push 	$s6

find_adjacent_cells__body:
	move 	$s0, $a0
	move 	$s1, $a1
	move 	$s2, $a2

	mul 	$t0, $s1, MAX_BOARD_WIDTH
	add 	$t0, $t0, $s2
	move 	$s3, $t0						# offset = row * MAX_BOARD_WIDTH + col;

	lb 	$t0, SIMULATED_BOARD_OFFSET($s0)			# char fill_region_colour = ...;

	add 	$t2, $s0, ADJACENT_TO_CELL_OFFSET
	add 	$t1, $t2, $s3
	lb 	$t3, ($t1)
	bne 	$t3, NOT_VISITED, find_adjacent_cells__epilogue		# if (... != NOT_VISITED) return;

	add 	$t2, $s0, SIMULATED_BOARD_OFFSET
	add 	$t1, $t2, $s3
	lb 	$t3, ($t1)
	bne 	$t3, $t0, find_adjacent_cells__adjacent_exit		# if (... != fill_region_colour)

	add 	$t2, $s0, ADJACENT_TO_CELL_OFFSET
	add 	$t1, $t2, $s3
	li 	$t3, VISITED
	sb 	$t3, ($t1)						# solver->... = VISITED;

	j 	find_adjacent_cells__loop_init

find_adjacent_cells__adjacent_exit:
	add 	$t2, $s0, ADJACENT_TO_CELL_OFFSET
	add 	$t1, $t2, $s3
	li 	$t3, ADJACENT
	sb 	$t3, ($t1)						# solver->... = ADJACENT;

	j 	find_adjacent_cells__epilogue

find_adjacent_cells__loop_init:
	li 	$s4, 0							# int i = 0;

find_adjacent_cells__loop_cond:
	bge 	$s4, NUM_VISIT_DELTAS, find_adjacent_cells__epilogue

find_adjacent_cells__loop_body:
	la 	$t1, visit_deltas

	mul 	$t2, $s4, 2
	addi 	$t2, $t2, VISIT_DELTA_ROW
	mul 	$t2, $t2, SIZEOF_INT
	add 	$t2, $t2, $t1
	lw 	$s5, ($t2)						# int row_delta = ...;

	mul 	$t2, $s4, 2
	addi 	$t2, $t2, VISIT_DELTA_COL
	mul 	$t2, $t2, SIZEOF_INT
	add 	$t2, $t2, $t1
	lw 	$s6, ($t2)						# int col_delta = ...;

	add 	$a0, $s1, $s5
	li 	$a1, 0
	lw 	$t0, board_height
	sub 	$a2, $t0, 1
	jal 	in_bounds						# if (!in_bounds(...)) continue;

	beqz 	$v0, find_adjacent_cells__loop_end

	add 	$a0, $s2, $s6
	li 	$a1, 0
	lw 	$t0, board_width
	sub 	$a2, $t0, 1
	jal 	in_bounds						# if (!in_bounds(...)) continue;

	beqz 	$v0, find_adjacent_cells__loop_end

	move 	$a0, $s0
	add 	$a1, $s1, $s5
	add 	$a2, $s2, $s6
	jal 	find_adjacent_cells					# find_adjacent_cells(...);

find_adjacent_cells__loop_end:
	addi 	$s4, $s4, 1						# i++;
	j 	find_adjacent_cells__loop_cond

find_adjacent_cells__epilogue:
	pop 	$s6
	pop 	$s5
	pop 	$s4
	pop 	$s3
	pop 	$s2
	pop 	$s1
	pop 	$s0
	pop 	$ra
	END
	jr	$ra							# return;



##########################################################################
## void fill(struct fill_in_progress *fill_in_progress,                 ##
##    char board[MAX_BOARD_WIDTH][MAX_BOARD_HEIGHT], int row, int col); ##
##########################################################################

################################################################################
# .TEXT <fill>
	.text
fill:
	# Subset:   3
	#
	# Frame:
	#   - $ra, $s0, $s1, $s2, $s3, $s4, $s5, $s6, $s7
	#
	# Uses:
	#   - $a0, $a1, $a2, $a3
	#   - $v0
	#   - $s0, $s1, $s2, $s3, $s4, $s5, $s6, $s7
	#   - $t0, $t1, $t2, $t3
	#
	# Clobbers:
	#   - $a0, $a1, $a2, $a3
	#   - $v0
	#   - $t0, $t1, $t2, $t3
	#
	# Locals:
	#   $s0: pointer to struct fill_in_progress
	#   $s1: pointer to board array
	#   $s2: row
	#   $s3: col
	#   $s4: offset = row * MAX_BOARD_WIDTH + col
	#   $s5: loop index i
	#   $s6: row_delta
	#   $s7: col_delta
	#
	# Structure:
	#   fill
	#   -> fill__prologue
	#   -> fill__body
	#       -> fill__add_cells_filled
	#       -> fill__pre_loop
	#           -> fill__loop_cond
	#               -> fill__loop_body
	#               -> fill__loop_end
	#   -> fill__epilogue

fill__prologue:
	BEGIN
	push 	$ra
	push 	$s0
	push 	$s1
	push 	$s2
	push 	$s3
	push 	$s4
	push 	$s5
	push 	$s6
	push 	$s7

fill__body:
	move 	$s0, $a0                                	# struct fill_in_progress *fill_in_progress
	move 	$s1, $a1                                	# char board[][]
	move 	$s2, $a2                                	# int row
	move 	$s3, $a3                                	# int col

	li 	$t0, MAX_BOARD_WIDTH
	mul 	$t0, $t0, $s2
	add 	$s4, $t0, $s3                           	# offset = row * MAX_BOARD_WIDTH + col

	addi 	$t0, $s0, VISITED_OFFSET
	add 	$t0, $t0, $s4
	lb 	$t1, ($t0)
	beq 	$t1, VISITED, fill__epilogue           		# if (visited[row][col] == VISITED) return;

	li 	$t1, VISITED
	sb 	$t1, ($t0)                               	# visited[row][col] = VISITED;

	add 	$t0, $s1, $s4
	lb 	$t1, ($t0)
	lb 	$t2, FILL_ONTO_OFFSET($s0)
	bne 	$t1, $t2, fill__epilogue                	# if (board[row][col] != fill_onto) return;

	lb 	$t2, FILL_WITH_OFFSET($s0)
	bne 	$t1, $t2, fill__add_cells_filled        	# if (board[row][col] != fill_with)

	j 	fill__pre_loop

fill__add_cells_filled:
	lw 	$t3, CELLS_FILLED_OFFSET($s0)
	addi 	$t3, $t3, 1
	sw 	$t3, CELLS_FILLED_OFFSET($s0)           	# cells_filled++;

fill__pre_loop:
	sb 	$t2, ($t0)                               	# board[row][col] = ...->fill_with;
	li 	$s5, 0                                   	# int i = 0;

fill__loop_cond:
	bge 	$s5, NUM_VISIT_DELTAS, fill__epilogue   	# for (i = 0; i < NUM_VISIT_DELTAS; i++)

fill__loop_body:
	la 	$t1, visit_deltas

	mul 	$t2, $s5, 2
	addi 	$t2, $t2, VISIT_DELTA_ROW
	mul 	$t2, $t2, SIZEOF_INT
	add 	$t2, $t2, $t1
	lw 	$s6, ($t2)                               	# row_delta = visit_deltas[i][VISIT_DELTA_ROW];

	mul 	$t2, $s5, 2
	addi 	$t2, $t2, VISIT_DELTA_COL
	mul 	$t2, $t2, SIZEOF_INT
	add 	$t2, $t2, $t1
	lw 	$s7, ($t2)                               	# col_delta = visit_deltas[i][VISIT_DELTA_COL];

	add 	$a0, $s2, $s6
	li 	$a1, 0
	lw 	$t0, board_height
	sub 	$a2, $t0, 1
	jal 	in_bounds
	beqz 	$v0, fill__loop_end                     	# if (!in_bounds(...)) continue;

	add 	$a0, $s3, $s7
	li 	$a1, 0
	lw 	$t0, board_width
	sub 	$a2, $t0, 1
	jal 	in_bounds
	beqz 	$v0, fill__loop_end                     	# if (!in_bounds(...)) continue;

	move 	$a0, $s0
	move 	$a1, $s1
	add 	$a2, $s2, $s6
	add 	$a3, $s3, $s7
	jal 	fill                                     	# fill(...);

fill__loop_end:
	addi 	$s5, $s5, 1                             	# i++;
	j 	fill__loop_cond

fill__epilogue:
	pop 	$s7
	pop 	$s6
	pop 	$s5
	pop 	$s4
	pop 	$s3
	pop 	$s2
	pop 	$s1
	pop 	$s0
	pop 	$ra
	END
	jr	$ra						# return;



##################################################
## void solve_next_step(struct solver *solver); ##
##################################################

################################################################################
# .TEXT <solve_next_step>
	.text
################################################################################
# .TEXT <solve_next_step>
	.text
solve_next_step:
	# Subset:   3
	#
	# Frame:
	#   - $ra, $s0, $s1, $s2, $s3, $s4
	#
	# Uses:
	#   - $a0, $a1, $a2
	#   - $v0
	#   - $s0, $s1, $s2, $s3, $s4
	#   - $t0, $t1, $t2, $t3, $t4
	#
	# Clobbers:
	#   - $a0, $a1, $a2
	#   - $v0
	#   - $t0, $t1, $t2, $t3, $t4
	#
	# Locals:
	#   - $s0: pointer to struct solver
	#   - $s1: best_surface_area
	#   - $s2: best_solution
	#   - $s3: loop counter i
	#   - $s4: MAX_BOARD_WIDTH * MAX_BOARD_HEIGHT
	#
	# Structure:
	#   solve_next_step
	#   -> solve_next_step__prologue
	#   -> solve_next_step__body
	#     -> solve_next_step__first_loop_init
	#       -> solve_next_step__first_loop_cond
	#         -> solve_next_step__first_loop_body
	#         -> solve_next_step__first_loop_invalid_step
	#       -> solve_next_step__first_loop_end
	#     -> solve_next_step__second_loop_init
	#       -> solve_next_step__second_loop_cond
	#         -> solve_next_step__second_loop_body
	#         -> solve_next_step__second_loop_is_eliminated
	#       -> solve_next_step__second_loop_end
	#     -> solve_next_step__third_loop_init
	#       -> solve_next_step__third_loop_cond
	#         -> solve_next_step__third_loop_body
	#         -> solve_next_step__third_loop_new_best
	#       -> solve_next_step__third_loop_end
	#   -> solve_next_step__epilogue

solve_next_step__prologue:
	BEGIN
	push 	$ra
	push 	$s0
	push 	$s1
	push 	$s2
	push 	$s3
	push 	$s4

solve_next_step__body:
	move 	$s0, $a0
	li 	$s1, -1								# int best_surface_area = -1;
	li 	$s2, -1								# int best_solution = -1;

	li 	$t0, MAX_BOARD_WIDTH
	li 	$t1, MAX_BOARD_HEIGHT
	mul 	$s4, $t0, $t1

	add 	$a0, $s0, SIMULATED_BOARD_OFFSET
	add 	$a1, $s0, FUTURE_BOARD_OFFSET
	move 	$a2, $s4
	jal 	copy_mem							# copy_mem(...);

solve_next_step__first_loop_init:
	li 	$s3, 0								# int i = 0;

solve_next_step__first_loop_cond:
	bge 	$s3, NUM_COLOURS, solve_next_step__first_loop_end		# for (int i = 0; ...)

solve_next_step__first_loop_body:
	add 	$a0, $s0, FUTURE_BOARD_OFFSET
	add 	$a1, $s0, SIMULATED_BOARD_OFFSET
	move 	$a2, $s4
	jal 	copy_mem							# copy_mem(...);

	move 	$a0, $s0
	move 	$a1, $s3
	jal 	invalid_step

	beq 	$v0, TRUE, solve_next_step__first_loop_invalid_step		# if (invalid_step(solver, i))

	move 	$a0, $s0
	move 	$a1, $s3
	jal 	simulate_step							# simulate_step(solver, i);

	move 	$a0, $s0
	jal 	initialise_solver_adjacent_cells				# initialise_...(solver);

	move 	$a0, $s0
	li 	$a1, 0
	li 	$a2, 0
	jal 	find_adjacent_cells						# find_adjacent_cells(...);

	move 	$a0, $s0
	move 	$a1, $s3
	jal 	rate_choice							# rate_choice(solver, i);

	addi 	$s3, $s3, 1							# i++;
	j 	solve_next_step__first_loop_cond

solve_next_step__first_loop_invalid_step:
	add 	$t0, $s0, STEP_RATING_FOR_COLOUR_OFFSET
	mul 	$t1, $s3, 8
	add 	$t0, $t0, $t1

	li 	$t2, FALSE
	sw 	$t2, IS_ELIMINATED_OFFSET($t0)					# solver->... = FALSE;

	li 	$t2, -1
	sw 	$t2, SURFACE_AREA_OFFSET($t0)					# solver->... = -1;

	addi 	$s3, $s3, 1							# i++;
	j 	solve_next_step__first_loop_cond

solve_next_step__first_loop_end:
	add 	$a0, $s0, FUTURE_BOARD_OFFSET
	add 	$a1, $s0, SIMULATED_BOARD_OFFSET
	move 	$a2, $s4
	jal 	copy_mem							# copy_mem(...);

solve_next_step__second_loop_init:
	li 	$s3, 0								# int i = 0;

solve_next_step__second_loop_cond:
	bge 	$s3, NUM_COLOURS, solve_next_step__second_loop_end		# for (int i = 0; ...)

solve_next_step__second_loop_body:
	lw 	$t1, IS_ELIMINATED_OFFSET($t0)
	beq 	$t1, TRUE, solve_next_step__second_loop_is_eliminated		# if (... .is_eliminated)

	addi 	$s3, $s3, 1							# i++;
	j 	solve_next_step__second_loop_cond

solve_next_step__second_loop_is_eliminated:
	add 	$t0, $s0, OPTIMAL_SOLUTION_OFFSET
	lw 	$t1, SOLUTION_LENGTH_OFFSET($s0)
	add 	$t2, $t0, $t1

	la 	$t3, colour_selector
	add 	$t3, $t3, $s3
	lb 	$t4, ($t3)
	sb 	$t4, ($t2)							# solver->... = ...[i];

	lw 	$t0, SOLUTION_LENGTH_OFFSET($s0)
	addi 	$t0, $t0, 1
	sw 	$t0, SOLUTION_LENGTH_OFFSET($s0)				# solver->solution_length++;

	move 	$a0, $s0
	move 	$a1, $s3
	jal 	simulate_step							# simulate_step(solver, i);

	add 	$a0, $s0, SIMULATED_BOARD_OFFSET
	add 	$a1, $s0, FUTURE_BOARD_OFFSET
	move 	$a2, $s4
	jal 	copy_mem							# copy_mem(...);

	j 	solve_next_step__epilogue

solve_next_step__second_loop_end:

solve_next_step__third_loop_init:
	li 	$s3, 0								# int i = 0;

solve_next_step__third_loop_cond:
	bge 	$s3, NUM_COLOURS, solve_next_step__third_loop_end		# for (int i = 0; ...)

solve_next_step__third_loop_body:
	add 	$t0, $s0, STEP_RATING_FOR_COLOUR_OFFSET
	mul 	$t1, $s3, 8
	add 	$t2, $t0, $t1
	lw 	$t3, ($t2)

	bgt 	$t3, $s1, solve_next_step__third_loop_new_best			# if (... > ...)

	addi 	$s3, $s3, 1							# i++;
	j 	solve_next_step__third_loop_cond

solve_next_step__third_loop_new_best:
	move 	$s2, $s3							# best_solution = i;
	move 	$s1, $t3							# best_surface_area = ...;

	addi 	$s3, $s3, 1							# i++;
	j 	solve_next_step__third_loop_cond

solve_next_step__third_loop_end:
	add 	$t0, $s0, OPTIMAL_SOLUTION_OFFSET
	lw 	$t1, SOLUTION_LENGTH_OFFSET($s0)
	add 	$t2, $t0, $t1

	la 	$t3, colour_selector
	add 	$t3, $t3, $s2
	lb 	$t4, ($t3)
	sb 	$t4, ($t2)							# solver->... = ...[...];

	lw 	$t0, SOLUTION_LENGTH_OFFSET($s0)
	addi 	$t0, $t0, 1
	sw 	$t0, SOLUTION_LENGTH_OFFSET($s0)				# solver->solution_length++;

	move 	$a0, $s0
	move 	$a1, $s2
	jal 	simulate_step							# simulate_step(...);

	add 	$a0, $s0, SIMULATED_BOARD_OFFSET
	add 	$a1, $s0, FUTURE_BOARD_OFFSET
	move 	$a2, $s4
	jal 	copy_mem							# copy_mem(...);

solve_next_step__epilogue:
	pop 	$s4
	pop 	$s3
	pop 	$s2
	pop 	$s1
	pop 	$s0
	pop 	$ra
	END
	jr	$ra								# return;



#########################################################
## void copy_mem(void *src, void *dst, int num_bytes); ##
#########################################################

################################################################################
# .TEXT <copy_mem>
	.text
copy_mem:
	# Subset:   3
	#
	# Frame:
	#   - $ra, $s0, $s1, $s2
	#
	# Uses:
	#   - $a0, $a1, $a2
	#   - $v0
	#   - $s0, $s1, $s2
	#   - $t0, $t1, $t2, $t3, $t4, $t5
	#
	# Clobbers:
	#   - $a0, $a1, $a2
	#   - $v0
	#   - $t0, $t1, $t2, $t3, $t4, $t5
	#
	# Locals:
	#   - $s0: loop index
	#   - $s1: number of whole words to copy
	#   - $s2: number of remaining bytes to copy
	#
	# Structure:
	#   copy_mem
	#   -> copy_mem__prologue
	#   -> copy_mem__body
	#     -> copy_mem__first_loop_init
	#       -> copy_mem__first_loop_cond
	#         -> copy_mem__first_loop_body
	#       -> copy_mem__first_loop_end
	#     -> copy_mem__second_loop_init
	#       -> copy_mem__second_loop_cond
	#         -> copy_mem__second_loop_body
	#       -> copy_mem__second_loop_end
	#   -> copy_mem__epilogue

copy_mem__prologue:
	BEGIN
	push 	$ra
	push 	$s0
	push 	$s1
	push 	$s2

copy_mem__body:
	move 	$t0, $a0				# int *src_int_ptr = (int*) src;
	move 	$t1, $a1				# int *dst_int_ptr = (int*) dst;

	div 	$s1, $a2, SIZEOF_INT
	rem 	$s2, $a2, SIZEOF_INT

copy_mem__first_loop_init:
	li 	$s0, 0					# int i = 0;

copy_mem__first_loop_cond:
	bge 	$s0, $s1, copy_mem__first_loop_end	# for (int i = 0; i < num_bytes / SIZEOF_INT; i++)

copy_mem__first_loop_body:
	lw 	$t2, ($t0)				# *dst_int_ptr = *src_int_ptr;
	sw 	$t2, ($t1)

	addi 	$t1, $t1, 4				# dst_int_ptr++;
	addi 	$t0, $t0, 4				# src_int_ptr++;

	addi 	$s0, $s0, 1				# i++;
	j 	copy_mem__first_loop_cond

copy_mem__first_loop_end:
	move 	$t3, $t0				# src_char_ptr = (char*) src_int_ptr;
	move 	$t4, $t1				# dst_char_ptr = (char*) dst_int_ptr;

copy_mem__second_loop_init:
	li 	$s0, 0					# int i = 0;

copy_mem__second_loop_cond:
	bge 	$s0, $s2, copy_mem__second_loop_end	# for (int i = 0; i < num_bytes % SIZEOF_INT; i++)

copy_mem__second_loop_body:
	lb 	$t5, ($t3)				# *dst_char_ptr = *src_char_ptr;
	sb 	$t5, ($t4)

	addi 	$t4, $t4, 1				# dst_char_ptr++;
	addi 	$t3, $t3, 1				# src_char_ptr++;

	addi 	$s0, $s0, 1				# i++;
	j 	copy_mem__second_loop_cond

copy_mem__second_loop_end:

copy_mem__epilogue:
	pop 	$s2
	pop 	$s1
	pop 	$s0
	pop 	$ra
	END
	jr	$ra					# return;



##############
## PROVIDED ##
##############

#######################################################################
## unsigned int random_in_range(unsigned int min, unsigned int max); ##
#######################################################################

################################################################################
# .TEXT <random_in_range>
	.text
random_in_range:
	# Subset:   provided
	#
	# Frame:    []
	# Uses:     [$t0, $t1, $t2, $v0]
	# Clobbers: [$t0, $t1, $t2, $v0]
	#
	# Locals:
	#   - $t0: int a;
	#   - $t1: int m;
	#   - $t2: (a * random_seed) % m
	#   - $v0: min + random_seed % (max - min + 1);
	#
	# Structure:
	#   initialise_solver
	#   -> [prologue]
	#       -> body
	#   -> [epilogue]
random_in_range__prologue:
random_in_range__body:
	li	$t0, 16807		# int a = 16807;
	li	$t1, 2147483647		# int m = 2147483647;
	lw	$t2, random_seed	# ... random_seed

	mul	$t2, $t2, $t0		# ... a * random_seed

	remu	$t2, $t2, $t1		# ... (a * random_seed) % m

	sw	$t2, random_seed	# random_seed = (a * random_seed) % m;

	move	$v0, $a1		# ... max
	sub	$v0, $v0, $a0		# ... max - min
	add	$v0, $v0, 1		# ... max - min + 1

	rem	$v0, $t2, $v0		# ... random_seed % (max - min + 1)
	add	$v0, $v0, $a0		# return min + random_seed % (max - min + 1);
random_in_range__epilogue:
	jr	$ra

####################################################
## void initialise_solver(struct solver *solver); ##
####################################################

################################################################################
# .TEXT <initialise_solver>
	.text
initialise_solver:
	# Subset:   provided
	#
	# Frame:    []
	# Uses:     [$a0, $a1, $a2]
	# Clobbers: [$a0, $a1, $a2]
	#
	# Locals:
	#   - $a0: game_board
	#   - $a1: solver->simulated_board
	#   - $a2: MAX_BOARD_WIDTH * MAX_BOARD_HEIGHT
	#
	# Structure:
	#   initialise_solver
	#   -> [prologue]
	#       -> body
	#   -> [epilogue]

initialise_solver__prologue:
	push	$ra
initialise_solver__body:
	sw	$zero, SOLUTION_LENGTH_OFFSET($a0)	# solver->solution_length = 0;

	la	$a1, SIMULATED_BOARD_OFFSET($a0)	# copy_mem(game_board, solver->simulated_board, MAX_BOARD_WIDTH * MAX_BOARD_HEIGHT);
	la	$a0, game_board				#
	li	$a2, MAX_BOARD_WIDTH			#
	mul	$a2, $a2, MAX_BOARD_HEIGHT		#
	jal	copy_mem				#

initialise_solver__epilogue:
	pop	$ra
	jr	$ra					# return;

##################################################################
## void simulate_step(struct solver *solver, int colour_index); ##
##################################################################

################################################################################
# .TEXT <simulate_step>
	.text
simulate_step:
	# Subset:   provided
	#
	# Frame:    [$s0]
	# Uses:     [$s0, $a0, $a1, $a2, $a3]
	# Clobbers: [$a0, $a1, $a2, $a3]
	#
	# Locals:
	#   - $s0: save argument struct solver *solver
	#   - $a0: &global_fill_in_progress
	#   - $a1: argument 2
	#   - $a2: 0
	#   - $a3: 0
	#
	# Structure:
	#   simulate_step
	#   -> [prologue]
	#       -> body
	#   -> [epilogue]

simulate_step__prologue:
	push	$ra
	push	$s0
simulate_step__body:
	move	$s0, $a0

	lb	$a2, SIMULATED_BOARD_OFFSET($a0)#
	la	$a0, global_fill_in_progress	# initialise_fill_in_progress(&global_fill_in_progress,
	lb	$a1, colour_selector($a1)	#     colour_selector[colour_index], solver->simulated_board[0][0]);
	jal	initialise_fill_in_progress	#

	la	$a0, global_fill_in_progress	# fill(&global_fill_in_progress, solver->simulated_board, 0, 0);
	la	$a1, SIMULATED_BOARD_OFFSET($s0)#
	li	$a2, 0				#
	li	$a3, 0				#
	jal	fill				#
simulate_step__epilogue:
	pop	$s0
	pop	$ra
	jr	$ra				# return;

###################################################################
## void initialise_solver_adjacent_cells(struct solver *solver); ##
###################################################################

################################################################################
# .TEXT <initialise_solver_adjacent_cells>
	.text
initialise_solver_adjacent_cells:
	# Subset:   provided
	#
	# Frame:    []
	# Uses:     [$t0, $t1, $t2, $t3]
	# Clobbers: []
	#
	# Locals:
	#   - $t0: int row;
	#   - $t1: int col;
	#   - $t2: address calculation & reading globals
	#   - $t3: value storage for sw
	#
	# Structure:
	#   initialise_solver_adjacent_cells
	#   -> [prologue]
	#       -> body
	#       -> row
	#           -> row_init
	#           -> row_cond
	#           -> row_body
	#           -> column
	#               -> column_init
	#               -> column_cond
	#               -> column_body
	#               -> column_step
	#               -> column_end
	#           -> row_step
	#           -> row_end
	#   -> [epilogue]

initialise_solver_adjacent_cells__prologue:
initialise_solver_adjacent_cells__body:
initialise_solver_adjacent_cells__row_init:
	li	$t0, 0				# int row = 0;
initialise_solver_adjacent_cells__row_cond:
	lw	$t2, board_height		# while (row < board_height) {
	bge	$t0, $t2, initialise_solver_adjacent_cells__row_end
						#
initialise_solver_adjacent_cells__row_body:
initialise_solver_adjacent_cells__column_init:
	li	$t1, 0				#     int col = 0;
initialise_solver_adjacent_cells__column_cond:
	lw	$t2, board_width		#     while (col < board_width) {
	bge	$t1, $t2, initialise_solver_adjacent_cells__column_end
						#
initialise_solver_adjacent_cells__column_body:
	mul	$t2, $t0, MAX_BOARD_WIDTH	#         ... &[row]
	add	$t2, $t2, $t1			#         ... &[row][col]
	add	$t2, $t2, $a0			#         ... &solver[row][col]
	li	$t3, NOT_VISITED		#
	sb	$t3, ADJACENT_TO_CELL_OFFSET($t2)
						#         solver->adjacent_to_cell[row][col] = NOT_VISITED;
initialise_solver_adjacent_cells__column_step:
	add	$t1, $t1, 1			#         col++;
	b	initialise_solver_adjacent_cells__column_cond
						#     }
initialise_solver_adjacent_cells__column_end:
initialise_solver_adjacent_cells__row_step:
	add	$t0, $t0, 1			#     row++;
	b	initialise_solver_adjacent_cells__row_cond
						# }
initialise_solver_adjacent_cells__row_end:

initialise_solver_adjacent_cells__epilogue:
	jr	$ra				# return;
######################################################################
## void print_board(char board[MAX_BOARD_WIDTH][MAX_BOARD_HEIGHT]); ##
######################################################################

################################################################################
# .TEXT <print_board>
	.text
print_board:
	# Subset:   provided
	#
	# Frame:    [$ra, $s0, $s1]
	# Uses:     [$s0, $s1, $t0, $a0, $v0]
	# Clobbers: [$t0, $a0, $v0]
	#
	# Locals:
	#   - $s0: char board[MAX_BOARD_WIDTH][MAX_BOARD_HEIGHT]
	#   - $s1: int i;
	#   - $t0: loading globals
	#   - $a0: syscall argument
	#   - $v0: syscall number
	#
	# Structure:
	#   print_board
	#   -> [prologue]
	#       -> body
	#       -> row
	#           -> row_init
	#           -> row_cond
	#           -> row_body
	#           -> row_step
	#           -> row_end
	#   -> [epilogue]

print_board__prologue:
	push	$ra
	push	$s0
	push	$s1
print_board__body:
	move	$s0, $a0
print_board__print_row_init:
	li	$s1, 0				# int i = 0;
print_board__print_row_cond:
	lw	$t0, board_height		# while (i < board_height) {
	bge	$s1, $t0, print_board__print_row_end
						#
print_board__print_row_body:
	move	$a0, $s0			#     print_board_row(board, i);
	move	$a1, $s1			#
	jal	print_board_row			#
print_board__print_row_step:
	add	$s1, $s1, 1			#     i++;
	b	print_board__print_row_cond	# }
print_board__print_row_end:
	jal	print_board_seperator_line	# print_board_seperator_line();
	jal	print_board_bottom		# print_board_bottom();

	lw	$a0, steps			# printf("%d", steps);
	li	$v0, 1				#
	syscall					#

	li	$a0, '/'			# putchar('/');
	li	$v0, 11				#
	syscall					#

	lw	$a0, optimal_steps		# printf("%d", optimal_steps + EXTRA_STEPS);
	add	$a0, $a0, EXTRA_STEPS		#
	li	$v0, 1				#
	syscall					#

	la	$a0, str_print_board_steps	# printf(" steps\n);
	li	$v0, 4				#
	syscall					#
print_board__epilogue:
	pop	$s1
	pop	$s0
	pop	$ra
	jr	$ra				# return;

################################
## void print_board_bottom(); ##
################################

################################################################################
# .TEXT <print_board_bottom>
	.text
print_board_bottom:
	# Subset:   provided
	#
	# Frame:    []
	# Uses:     [$t0, $t1, $t2, $t3, $a0, $v0]
	# Clobbers: [$t0, $t1, $t2, $t3, $a0, $v0]
	#
	# Locals:
	#   - $t0: int i;
	#   - $t1: int j;
	#   - $t2: int k;
	#   - $t3: arithmetic & loading globals
	#   - $a0: syscall argument
	#   - $v0: syscall number
	#
	# Structure:
	#   print_board_bottom
	#   -> [prologue]
	#       -> body
	#       -> down
	#           -> down_init
	#           -> down_cond
	#           -> down_body
	#           -> down_step
	#           -> down_end
	#           -> across
	#               -> across_init
	#               -> across_cond
	#               -> across_body
	#               -> not_selected
	#                   -> not_selected_init
	#                   -> not_selected_cond
	#                   -> not_selected_body
	#                   -> not_selected_step
	#                   -> not_selected_end
	#               -> selected
	#                   -> selected1
	#                       -> selected1_init
	#                       -> selected1_cond
	#                       -> selected1_body
	#                       -> selected1_step
	#                       -> selected1_end
	#                   -> i
	#                       -> i_nonzero
	#                       -> i_end
	#                   -> selected2
	#                       -> selected2_init
	#                       -> selected2_cond
	#                       -> selected2_body
	#                       -> selected2_step
	#                       -> selected2_end
	#               -> across_step
	#               -> across_end
	#   -> [epilogue]

print_board_bottom__prologue:
print_board_bottom__body:
print_board_bottom__down_init:
	li	$t0, 0				# int i = 0;
print_board_bottom__down_cond:
	bge	$t0, SELECTED_ARROW_VERTICAL_LENGTH + 1, print_board_bottom__down_end
						# while (i < SELECTED_ARROW_VERTICAL_LENGTH + 1) {
print_board_bottom__down_body:
	li	$v0, 11				#     putchar(BOARD_SPACE_SEPERATOR);
	li	$a0, BOARD_SPACE_SEPERATOR	#
	syscall					#
print_board_bottom__across_init:
	li	$t1, 0				#     int j = 0;
print_board_bottom__across_cond:
	lw	$t3, board_width		#     while (j < board_width) {
	bge	$t1, $t3, print_board_bottom__across_end
						#
print_board_bottom__across_body:

	lw	$t3, selected_column		#         if (j != selected_column) {
	beq	$t1, $t3, print_board_bottom__across_selected
						#

print_board_bottom__not_selected_init:
	li	$t2, 0				#             int k = 0;
print_board_bottom__not_selected_cond:
	bge	$t2, BOARD_CELL_SIZE + 3, print_board_bottom__not_selected_end
						#             while (k < BOARD_CELL_SIZE + 3) {
print_board_bottom__not_selected_body:
	li	$a0, BOARD_SPACE_SEPERATOR	#                 putchar(BOARD_SPACE_SEPERATOR);
	li	$v0, 11				#
	syscall					#
print_board_bottom__not_selected_step:
	add	$t2, $t2, 1			#                 k++;
	b	print_board_bottom__not_selected_cond
						#             }
print_board_bottom__not_selected_end:
	b	print_board_bottom__across_step	#         } else {
print_board_bottom__across_selected:
print_board_bottom__across_selected1_init:
	li	$t2, 0				#             int k = 0;
print_board_bottom__across_selected1_cond:
	li	$t3, BOARD_CELL_SIZE + 1	#             while (k < (BOARD_CELL_SIZE + 1) / 2) {
	div	$t3, $t3, 2			#
	bge	$t2, $t3, print_board_bottom__across_selected1_end
						#
print_board_bottom__across_selected1_body:
	li	$a0, BOARD_SPACE_SEPERATOR	#                 putchar(BOARD_SPACE_SEPERATOR);
	li	$v0, 11				#
	syscall					#
print_board_bottom__across_selected1_step:
	add	$t2, $t2, 1			#                 k++;
	b	print_board_bottom__across_selected1_cond
						#             }
print_board_bottom__across_selected1_end:

	bnez	$t0, print_board_bottom__across_i_nonzero
						#             if (i == 0) {

	li	$a0, BOARD_SPACE_SEPERATOR	#                 putchar(BOARD_SPACE_SEPERATOR);
	li	$v0, 11				#
	syscall					#

	b	print_board_bottom__across_i_end
						#             } else {
print_board_bottom__across_i_nonzero:

	sub	$a0, $t0, 1			#                 putchar(selected_arrow_vertical[i - 1]);
	lb	$a0, selected_arrow_vertical($a0)
						#
	li	$v0, 11				#
	syscall					#

print_board_bottom__across_i_end:		#             }

print_board_bottom__across_selected2_init:
	li	$t2, 0				#             k = 0;
print_board_bottom__across_selected2_cond:
	li	$t3, BOARD_CELL_SIZE + 1	#             while (k < ((BOARD_CELL_SIZE + 1) / 2)) {
	div	$t3, $t3, 2			#
	bge	$t2, $t3, print_board_bottom__across_selected2_end
						#
print_board_bottom__across_selected2_body:
	li	$a0, BOARD_SPACE_SEPERATOR	#                 putchar(BOARD_SPACE_SEPERATOR);
	li	$v0, 11				#
	syscall					#

print_board_bottom__across_selected2_step:
	add	$t2, $t2, 1			#                 k++;
	b	print_board_bottom__across_selected2_cond
						#             }
print_board_bottom__across_selected2_end:

print_board_bottom__across_step:
	add	$t1, $t1, 1			#         j++;
	b	print_board_bottom__across_cond	#     }
print_board_bottom__across_end:

	li	$a0, BOARD_SPACE_SEPERATOR	#     putchar(BOARD_SPACE_SEPERATOR);
	li	$v0, 11				#
	syscall					#

	li	$a0, '\n'			#     putchar('\n');
	syscall					#

print_board_bottom__down_step:
	add	$t0, $t0, 1			#     i++;
	b	print_board_bottom__down_cond	# }
print_board_bottom__down_end:
print_board_bottom__epilogue:
	jr	$ra				# return;

#########################################################################
## void print_board_row(char board[MAX_BOARD_WIDTH][MAX_BOARD_HEIGHT], ##
##     int row);                                                       ##
#########################################################################

################################################################################
# .TEXT <print_board_row>
	.text
print_board_row:
	# Subset:   provided
	#
	# Frame:    [$ra, $s0, $s1, $s2]
	# Uses:     [$s0, $s1, $s2, $t0, $t1, $a0, $a1, $a2]
	# Clobbers: [$t0, $t1, $a0, $a1, $a2]
	#
	# Locals:
	#   - $s0: char board[MAX_BOARD_WIDTH][MAX_BOARD_HEIGHT]
	#   - $s1: int row
	#   - $s2: int i
	#   - $t0: i == BOARD_CELL_SIZE / 2
	#   - $t1: row == selected_row
	#   - $a0: char board[MAX_BOARD_WIDTH][MAX_BOARD_HEIGHT]
	#   - $a1: int row
	#   - $a2: i == BOARD_CELL_SIZE / 2 && row == selected_row
	#
	# Structure:
	#   print_board_row
	#   -> [prologue]
	#       -> body
	#       -> each_row
	#           -> each_row_init
	#           -> each_row_cond
	#           -> each_row_body
	#           -> each_row_step
	#           -> each_row_end
	#   -> [epilogue]

print_board_row__prologue:
	push	$ra
	push	$s0
	push	$s1
	push	$s2
print_board_row__body:
	move	$s0, $a0
	move	$s1, $a1

	jal	print_board_seperator_line	# print_board_seperator_line();

print_board_row__each_row_init:
	li	$s2, 0				# int i = 0;
print_board_row__each_row_cond:
	bge	$s2, BOARD_CELL_SIZE, print_board_row__each_row_end
						# while (i < BOARD_CELL_SIZE) {
print_board_row__each_row_body:
	move	$a0, $s0			#
	move	$a1, $s1			#

	li	$t0, BOARD_CELL_SIZE		#
	div	$t0, $t0, 2			#
	seq	$t0, $t0, $s2			# ... i == BOARD_CELL_SIZE / 2

	lw	$t1, selected_row		#
	seq	$t1, $s1, $t1			# ... row == selected_row
	and 	$a2, $t0, $t1			# ... i == BOARD_CELL_SIZE / 2 && row == selected_row

	jal	print_board_inner_line		# print_board_inner_line(board, row, i == BOARD_CELL_SIZE / 2 && row == selected_row);
print_board_row__each_row_step:
	add	$s2, $s2, 1			#     i++;
	b	print_board_row__each_row_cond	# }
print_board_row__each_row_end:

print_board_row__epilogue:
	pop	$s2
	pop	$s1
	pop	$s0
	pop	$ra
	jr	$ra				# return;

################################################################################
## void print_board_inner_line(char board[MAX_BOARD_WIDTH][MAX_BOARD_HEIGHT], ##
##     int row, int row_is_selected);                                         ##
################################################################################

################################################################################
# .TEXT <print_board_inner_line>
	.text
print_board_inner_line:
	# Subset:   provided
	#
	# Frame:    []
	# Uses:     [$t0, $t1, $t2, $t3, $a0, $v0]
	# Clobbers: [$t0, $t1, $t2, $t3, $a0, $v0]
	#
	# Locals:
	#   - $t0: char board[MAX_BOARD_WIDTH][MAX_BOARD_HEIGHT]
	#   - $t1: int i;
	#   - $t2: int j;
	#   - $t3: loading globals
	#   - $a0: syscall argument
	#   - $v0: syscall number
	#
	# Structure:
	#   print_board_inner_line
	#   -> [prologue]
	#       -> body
	#       -> cells
	#           -> cells_init
	#           -> cells_cond
	#           -> cells_body
	#           -> inner_cell
	#               -> inner_cell_init
	#               -> inner_cell_cond
	#               -> inner_cell_body
	#               -> inner_cell_step
	#               -> inner_cell_end
	#           -> cells_step
	#           -> cells_end
	#   -> [epilogue]

print_board_inner_line__prologue:
print_board_inner_line__body:
	move	$t0, $a0

	li	$a0, BOARD_VERTICAL_SEPERATOR	# putchar(BOARD_VERTICAL_SEPERATOR);
	li	$v0, 11				#
	syscall					#

print_board_inner_line__cells_init:
	li	$t1, 0				# int i = 0;
print_board_inner_line__cells_cond:
	lw	$t3, board_width		# while (i < board_width) {
	bge	$t1, $t3, print_board_inner_line__cells_end
						#
print_board_inner_line__cells_body:
	li	$a0, BOARD_SPACE_SEPERATOR	#     putchar(BOARD_SPACE_SEPERATOR);
	li	$v0, 11				#
	syscall					#

print_board_inner_line__inner_cell_init:
	li	$t2, 0				#     int j = 0;
print_board_inner_line__inner_cell_cond:
	bge	$t2, BOARD_CELL_SIZE, print_board_inner_line__inner_cell_end
						#     while (j < BOARD_CELL_SIZE) {
print_board_inner_line__inner_cell_body:
	mul	$a0, $a1, MAX_BOARD_WIDTH	#         ... &[row]
	add	$a0, $a0, $t0			#         ... &board[row]
	add	$a0, $a0, $t1			#         ... &board[row][col]
	lb	$a0, ($a0)			#         putchar(board[row][i]);
	li	$v0, 11				#
	syscall
print_board_inner_line__inner_cell_step:
	add	$t2, $t2, 1			#         j++;
	b	print_board_inner_line__inner_cell_cond
						#     }
print_board_inner_line__inner_cell_end:

	li	$a0, BOARD_SPACE_SEPERATOR	#     putchar(BOARD_SPACE_SEPERATOR);
	li	$v0, 11				#
	syscall					#

	lw	$t3, board_width		#     if (i != board_width - 1) {
	sub	$t3, $t3, 1			#
	beq	$t1, $t3, print_board_inner_line__cells_step
						#

	li	$a0, BOARD_CELL_SEPERATOR	#         putchar(BOARD_CELL_SEPERATOR);
	li	$v0, 11				#
	syscall					#

print_board_inner_line__cells_step:		#     }
	add	$t1, $t1, 1			#     i++;
	b	print_board_inner_line__cells_cond
						# }
print_board_inner_line__cells_end:

	li	$a0, BOARD_VERTICAL_SEPERATOR	# putchar(BOARD_VERTICAL_SEPERATOR);
	li	$v0, 11				#
	syscall					#

	beqz	$a2, print_board_inner_line__last_newline
						# if (row_is_selected) {

	li	$a0, BOARD_SPACE_SEPERATOR	#     putchar(BOARD_SPACE_SEPERATOR);
	li	$v0, 11				#
	syscall					#

	la	$a0, selected_arrow_horizontal	#     printf("%s", selected_arrow_horizontal);
	li	$v0, 4				#
	syscall					#

print_board_inner_line__last_newline:		# }
	li	$a0, '\n'			#
	li	$v0, 11				#
	syscall					#
print_board_inner_line__epilogue:
	jr	$ra				# return;

########################################
## void print_board_seperator_line(); ##
########################################

################################################################################
# .TEXT <print_board_seperator_line>
	.text
print_board_seperator_line:
	# Subset:   provided
	#
	# Frame:    []
	# Uses:     [$t0, $t1, $t2, $a0, $v0]
	# Clobbers: [$t0, $t1, $t2, $a0, $v0]
	#
	# Locals:
	#   - $t0: int i;
	#   - $t1: int j;
	#   - $t2: globals
	#   - $a0: syscall argument
	#   - $v0: syscall number
	#
	# Structure:
	#   print_board_seperator_line
	#   -> [prologue]
	#       -> body
	#       -> line
	#           -> line_init
	#           -> line_cond
	#           -> line_body
	#           -> line_step
	#           -> line_end
	#           -> inner_line
	#               -> inner_line_init
	#               -> inner_line_cond
	#               -> inner_line_body
	#               -> inner_line_step
	#               -> inner_line_end
	#   -> [epilogue]

print_board_seperator_line__prologue:
print_board_seperator_line__body:
	li	$a0, BOARD_VERTICAL_SEPERATOR	# putchar(BOARD_VERTICAL_SEPERATOR);
	li	$v0, 11				#
	syscall					#

print_board_seperator_line__line_init:
	li	$t0, 0				# int i = 0;
print_board_seperator_line__line_cond:
	lw	$t2, board_width		#
	bge	$t0, $t2, print_board_seperator_line__line_end
						# while (i < board_width) {
print_board_seperator_line__line_body:

print_board_seperator_line__inner_line_init:
	li	$t1, 0				#     int j = 0;
print_board_seperator_line__inner_line_cond:
	bge	$t1, BOARD_CELL_SIZE + 2, print_board_seperator_line__inner_line_end
						#     while (j < BOARD_CELL_SIZE + 2) {
print_board_seperator_line__inner_line_body:
	li	$a0, BOARD_HORIZONTAL_SEPERATOR	#         putchar(BOARD_HORIZONTAL_SEPERATOR);
	li	$v0, 11				#
	syscall					#
print_board_seperator_line__inner_line_step:
	add	$t1, $t1, 1			#         j++;
	b	print_board_seperator_line__inner_line_cond
						#     }
print_board_seperator_line__inner_line_end:
	lw	$t2, board_width		#     if (i != board_width - 1) {
	sub	$t2, $t2, 1			#
	beq	$t2, $t0, print_board_seperator_line__line_step
						#

	li	$a0, BOARD_CROSS_SEPERATOR	#         putchar(BOARD_CROSS_SEPERATOR);
	li	$v0, 11				#
	syscall					#

print_board_seperator_line__line_step:		#     }
	add	$t0, $t0, 1			#     i++;
	b	print_board_seperator_line__line_cond
						# }
print_board_seperator_line__line_end:

	li	$a0, BOARD_VERTICAL_SEPERATOR	# putchar(BOARD_VERTICAL_SEPERATOR);
	li	$v0, 11				#
	syscall					#

	li	$a0, '\n'			# putchar('\n');
	syscall					#

print_board_seperator_line__epilogue:
	jr	$ra				# return;

#############################
## void process_command(); ##
#############################

################################################################################
# .TEXT <process_command>
	.text
process_command:
	# Subset:   provided
	#
	# Frame:    [$ra]
	# Uses:     [$t0, $t1, $a0, $v0]
	# Clobbers: [$t0, $t1, $a0, $v0]
	#
	# Locals:
	#   - $t0: char command;
	#   - $t1: globals
	#   - $a0: syscall argument
	#   - $v0: syscall number
	#
	# Structure:
	#   process_command
	#   -> [prologue]
	#       -> body
	#       -> good_parsing
	#           -> good_parsing_cond
	#           -> good_parsing_end
	#       -> up
	#           -> up
	#           -> up_in_bounds
	#       -> down
	#           -> down
	#           -> down_in_bounds
	#       -> right
	#           -> right
	#           -> right_in_bounds
	#       -> left
	#           -> left
	#           -> left_in_bounds
	#       -> quit
	#       -> fill
	#       -> help
	#       -> cheat
	#       -> unknown
	#       -> end_switch
	#   -> [epilogue]

process_command__prologue:
	push	$ra
process_command__body:
	la	$a0, cmd_waiting
	li	$v0, 4
	syscall

	li	$v0, 12
	syscall
	move	$t0, $v0
process_command__good_parsing_cond:
	bne	$t0, '\n', process_command__good_parsing_end
	li	$v0, 12
	syscall
	move	$t0, $v0
	b	process_command__good_parsing_cond
process_command__good_parsing_end:
	beq	$t0, 'w', process_command__up		# switch (command) {
	beq	$t0, 's', process_command__down		#
	beq	$t0, 'd', process_command__right	#
	beq	$t0, 'a', process_command__left		#
	beq	$t0, 'q', process_command__quit		#
	beq	$t0, 'e', process_command__fill		#
	beq	$t0, 'h', process_command__help		#
	beq	$t0, 'c', process_command__cheat	#
	b	process_command__unknown		#
process_command__up:					#     case 'w':
	lw	$t0, selected_row			#         selected_row = MAX(selected_row - 1, 0);
	sub	$t0, $t0, 1				#
	bge	$t0, 0, process_command__up_in_bounds	#
	li	$t0, 0					#
process_command__up_in_bounds:
	sw	$t0, selected_row			#
	b	process_command__end_switch		#         break;
process_command__down:					#     case 's':
	lw	$t0, selected_row			#         selected_row = MIN(selected_row + 1, board_height - 1);
	add	$t0, $t0, 1				#
	lw	$t1, board_height			#
	sub	$t1, $t1, 1				#
	ble	$t0, $t1, process_command__down_in_bounds
							#
	move	$t0, $t1				#
process_command__down_in_bounds:			#
	sw	$t0, selected_row			#
	b	process_command__end_switch		#         break;
process_command__right:					#     case 'd':
	lw	$t0, selected_column			#         selected_column = MIN(selected_column + 1, board_width - 1)
	add	$t0, $t0, 1				#
	lw	$t1, board_width			#
	sub	$t1, $t1, 1				#
	ble	$t0, $t1, process_command__right_in_bounds
							#
	move	$t0, $t1				#
process_command__right_in_bounds:			#
	sw	$t0, selected_column			#
	b	process_command__end_switch		#         break;
process_command__left:					#     case 'a':
	lw	$t0, selected_column			#         selected_column = MAX(selected_column - 1, 0);
	sub	$t0, $t0, 1				#
	bge	$t0, 0, process_command__left_in_bounds	#
	li	$t0, 0					#
process_command__left_in_bounds:			#
	sw	$t0, selected_column			#
	b	process_command__end_switch		#         break;
process_command__quit:					#     case 'q':
	li	$v0, 10					#         exit(0);
	syscall						#
process_command__fill:					#     case 'e':
	jal	do_fill					#         do_fill();
	b	process_command__end_switch		#         break;
process_command__help:					#     case 'h':
	jal	print_welcome				#         print_welcome();
	b	process_command__epilogue		#         return;
process_command__cheat:					#     case 'c':
	jal	print_optimal_solution			#         print_optimal_solution();
	b	process_command__epilogue		#         return;
process_command__unknown:				#     default:
	la	$a0, str_process_command_unknown	#         printf("Unknown command: ");
	li	$v0, 4					#
	syscall						#

	move	$a0, $t0				#         putchar(command);
	li	$v0, 11					#
	syscall						#

	li	$a0, '\n'				#         putchar('\n')
	syscall						#
	b	process_command__epilogue		#         return;
process_command__end_switch:				# }

	la	$a0, game_board
	jal	print_board				# print_board(game_board);

process_command__epilogue:
	pop	$ra
	jr	$ra					# return;
